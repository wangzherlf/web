[{"title":"koa.md","url":"/web/2019/07/03/koa/","content":"## 什么是Node.js\n\nnode.js是一个基于chrome v8引擎的javascript运行时环境。使用了事件驱动、非阻塞式I/O模型\n`运行时环境`也叫运行时Managed Runtime Environment，即托管运行时环境\n运行时是一个平台，它把运行在底层操作系统和体系结构的特点抽象出来，承担了解释与编译、堆管理(Heap Management)、垃圾回收机制(Garbage Collection)、内存分配(Memory Allocation)、安全机制(Security)等功能\n运行时环境也叫做虚拟机\n\njavascirpt运行时环境是一个能够运行javascript语句的运行环境，它提供了一些列以往由处理器和操作系统才能提供的功能，使得开发者能够脱离底层指令，从而专注业务逻辑开发\n\nchrome v8引擎是一个高性能的javascript解释引擎。chrome浏览器内核是webkit的一个分支。webkit分为渲染引擎webCore和js解释引擎javascriptCore两个部分。google认为javascriptCore引擎运行效率不高，因此开发了高性能的javascript引擎v8\n\n\n\n**使用node.js搭建一个http server**\n\n```\nconst http = require('http')\nconst fs = require('fs')\nconst url = require('url')\nconst path = require('path')\nconst hostname = '127.0.0.1'\nconst port = 8080\n\nconst server = http.createServer((req, res) => {\n    let pathname = url.parse(req.url).pathname\n    let extname = url.parse(pathname)\n    if (pathname == '/') {\n        res.writeHead(200, {'Content-Type': 'text/html'})\n        res.end(fs.readFileSync(path.join(__dirname, pathname, 'test.html')))\n    } else if (extname == '.jpg' || extname == '.png') {\n        res.writeHead(200, {'Content-Type': 'image/' + extname.substr(1)})\n        res.end(fs.readFileSync(path.join(__dirname, pathname)))\n    } else {\n        res.statusCode = 404;\n        res.end()\n    }\n})\n\nserver.listen(port, hostname, () => {\n    console.log(`server running at http://${hostname}:${port}`)\n})\n\n```\n\n## Npm\n\n[npm](https://docs.npmjs.com) (Node Package Manager)是一个javascript模块管理工具，遵循CommonJS标准\n\n用于管理模块的安装、卸载和依赖项\n\n**npm常用命令**\n\n```\nnpm access           设置模块的访问级别\nnpm adduser          添加用户\nnpm cache (npm -c)   管理模块缓存\nnpm config           管理Npm配置文件\nnpm help (npm -h)    查看npm帮助信息\nnpm init             引导创建package,json文件\nnpm ls               查看已安装的模块\nnpm publish          发布模块\nnpm root             显示Npm根目录\nnpm start            启动模块\nnpm test             测试模块\nnpm update (npm -up) 更新模块\nnpm verison (npm -v) 查看npm版本信息\nnpm init -y          初始化\nnpm init —yes        初始化\nnpm root -g          查看全局包位置\n```\n\n### 完全符合CommonJS规范的npm模块结构\n\n```\npackage.json  模块的描述文件\nbin    存放可执行的二进制文件\nlib    存放javascript代码\ndoc    存放文档\ntest   存放单元测试用例\n```\n\n### [package.json常用字段](https://docs.npmjs.com/files/package.json)\n\n```\ndescription       模块描述\nname              模块名字\nversion           版本号\nkeywords          关键字\nlicense           许可证\nauthor            开发者\nscripts           可用于运行的脚本命令\ndependencies      正常运行时所需的模块\ndevDependencies   开发时所需的模块\n```\n\n对于相同的package.json文件，输入安装命令，输出的模块包应该是一致的，然后并不一致，主要原因是\n\n- npm采用的安装算法稍有不同\n- 在最近一次安装之后，模块进行了版本更新，由于会自动采用最新版本(而非预先设定的版本)\n- 即使锁定了版本信息，如果模块的依赖包进行了更新，模块也会自动更新\n- 更新了新的下载源\n\n这些都是因为Npm的版本兼容机制非常宽松造成的。\n\n`package-lock.json` 锁定了依赖版本号和来源，是npm为了防止模块包的不一致而进行的功能加强。这个文件在运行命令`npm install`的时候为了锁定依赖版本和来源由npm自动创建，记录了当前状态下安装的所有模块信息，确保了在下载时间，开发者，机器和下载源都不相同的情况下也能够得到完全一样的模块包\n\n## NVM\n\n1. 卸载已经全局安装的node.js和npm(推荐，非必须)\n\n   - 删除`/usr/local/lib`和`/usr/local/include`两个文件夹中所有和node.js及node_modules相关的文件\n\n   - 检查个人主文件夹下所有`local`,`lib`,`include`文件夹并删除所有与node.js和node_modules有关的内容\n\n   - 从`/usr/local/bin`中删除node.js的可执行文件\n\n   - 使用brew安装的node.js还需要运行`brew uninstall node`命令来卸载\n\n   - 运行\n\n     ```\n     sudo rm -rf /usr/local/bin/npm /usr/local/share/main/main1/node* /usr/local/lib/dtrace/node.d ~/.npm ~/.node-gyp\n     \n     sudo rm -rf /opt/local/bin/node /opt/local/include/node /opt/local/lib/node_modules\n     ```\n\n2. [安装NVM](https://blog.csdn.net/zmm13298329239/article/details/83587214)\n\n   - 在安装NVM之前还需要一个C++编译器，在mac上可以安装Xcode命令行工具\n     `xcode-select -install`\n\n   - 使用curl或wget安装nvm\n\n     ```\n     curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash\n     \n     wget -q0- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash\n     ```\n\n     输入` comman -v nvm` 查看是否安装成功\n     如果安装失败需要配置环境变量`~/.bash_profile`\n\n     ```\n     export NVM_DIR=\"$HOME/.nvm\"\n     [ -s \"$NVM_DIR/nvm.sh\" ] && . \"$NVM_DIR/nvm.sh\"\n     ```\n\n     使环境变量生效\n\n     ```\n     source ~/.bash_profile\n     ```\n\n     如果配置环境变量还失败需要在`.bash_profile`文件中添加 `source ~/.bashrc`\n\n3. [安装并切换不同node.js版本](https://github.com/nvm-sh/nvm#usage)\n\n   ```\n   nvm install stable  安装最新稳定版node.js\n   nvm install 9.11.1  安装9.11.1版本\n   nvm install 9.11    安装9.11.x系列最新版本\n   nvm ls-remote       列出远程服务器上所有可用版本\n   nvm use 9.11.1      切换到9.11.1\n   nvm use 9.11        切换到9.11.x 系列最新版\n   nvm use node        切换到最新版\n   nvm nvm alias default node  设置默认版本为最新版\n   nvm ls              列出所有已经安装的版本\n   ```\n\n4. 配置项目所使用的node.js版本\n   如果项目所需node.js版本不是默认版本，可以在项目根目录创建`.nvmrc`文件并在其中预先指定版本号\n\n   ```\n   echo 9.11.1 > .nvmrc   创建.nvmrc文件\n   nvm use    运行nmv，将自动安装设定好的版本号\n   ```\n\n   \n\n## 在npm.org上发布一个模块\n\n1. [注册账号](https://www.npmjs.com/signup)\n2. 添加用户名, 密码及邮箱 `npm adduser`\n3. 发布 `npm publish`\n\n## KOA\n\n### Express和Koa的区别\n\n- Express4之前主要是基于Connect，封装了大量的功能，如路由，视图处理，错误处理等。Express4之后不再依赖connect,除了express.static外的内置中间件，全部作为单独的模块安装 \n\n- Express框架采用ES5语法，异步操作通过传统的回调异步调用，会容易造成回调地狱\n\n- Express的插件是顺序执行的，Koa的中间件是基于洋葱模型，可以在中间件中执行请求处理前和请求处理后的代码\n- Koa不在内核中绑定任何中间件，仅仅提供了一个轻量的函数库，几乎所有功能都需要通过第三方中间件来实现\n\nES6 generator...yield+promise \n\n```\nfunction* () { yiels xxx; }\n```\n\nES7 async...await+promise\n\n```\nasync function() { await xxx; }\n```\n\n## koa安装及搭建\n\nkoa2需要node.js7.6以上，如果低于7.6需要使用babel hook\n\n```\nrequire('babel-register')  // babel hook\n// 应用的其余require需要放到hook后面\nconst app = require('./app')\n```\n\n1. 初始化项目 `npm init`\n2. 安装koa `npm install koa --save`\n\n### context对象\n\nkoa将node.js的request和response对象封装到context对象中，context是会话的上下文\n\ncontext对象内置了一些常用属性，如`context.state`, `context.app`, `context.cookies`, `context.throw`，也可以在context对象中定义一些属性、配置以供全局使用\n\nkoa应用程序中的每个请求都会创建一个context，并在中间件中被作为参数引用\n\n```\napp.use(async ctx => {\n    ctx            // context\n    ctx.request    // koa request\n    ctx.response   // koa response\n})\n```\n\n### 常用属性和方法\n\n1. `ctx.request`\n\n   koa request对象是在node.js的请求对象上的封装\n\n   如果要访问node.js的request对象，需要使用 `ctx.req`\n\n   ```\n   ctx.request.url           // 获取请求URL\n   ctx.request.query          // 获取解析后的查询字符串\n   ctx.request.querystring   // 获取原始查询字符串\n   ctx.request.method       //  请求类型 POST GET\n   ctx.request.path         // 请求路径\n   ctx.request.accepts('json') // 期望服务端返回的数据类型\n   ```\n\n   Koa没有封装获取POST请求参数的方法，需要使用node.js请求对象req\n\n   ```\n   app.use(async ctx => {\n    let postdata = ''\n    ctx.req.on('data', data => {\n        postdata += data\n    })\n    ctx.req.on('end', () => {\n        console.log(postdata)\n    })\n   })\n   ```\n\n   curl命令可以模拟POST请求， `-d`参数后面是POST请求得从那时\n\n   ```\n   curl -d 'params1=value1&params2=value2' http://localhost:3000\n   ```\n\n   可以使用`koa-bodyparser  `中间件来获取POST请求得参数\n\n2. ctx.response\n\n   ctx.response是Koa对node.js原生response的抽象\n\n   ```\n   ctx.response.type  // 响应Content-Type类型 html, image/jpeg, text/plain, text\n   ctx.response.body  // 响应体\n   ctx.response.status   // 设置响应状态 200 404\n   ctx.response.is(types...)  // 与ctx.request.is(types…)类似，用来检查响应类型是否是所提供的类型之一\n   ctx.response.redirect(url, [alt])  // 用于将302状态码重定向到URL，如用户登录后重定向到网站的首页\n   ```\n\n3. ctx.state\n\n   `ctx.state`是推荐的命名空间，用于通过中间件传递信息和前端视图。类似koa-views这些渲染view层的中间件也会默认把ctx.state里的属性作为view的上下文传入\n\n   ```\n   ctx.state.user = yield User.find(id)\n   ```\n\n   把user属性存放到`ctx.state`对象里，以便能够被另一个中间件读取\n\n4. ctx.cookies\n\n   `ctx.cookies`用于获取和设置cookie\n\n   ```\n   ctx.cookies.get(name, [options])  // 获取cookie\n   ctx.cookies.set(name, value, [options])  // 设置cookie\n   ```\n\n   options的配置：\n\n   | key       | value                                                    |\n   | --------- | -------------------------------------------------------- |\n   | maxAge    | 一个以毫秒为单位的数字，表示cookie过期时间               |\n   | signed    | cookie签名值                                             |\n   | expires   | cookie过期的Date                                         |\n   | path      | cookie路径，默认/                                        |\n   | domain    | cookie域名                                               |\n   | secure    | 安全cookie,只能使用HTTPS访问                             |\n   | httpOnly  | 如果为true,则cookie无法被javascript获取到                |\n   | overwrite | 一个布尔值，表示是否覆盖以前设置的同名cookie (默认false) |\n\n5. ctx.throw\n\n   `ctx.throw`用于抛出错误，把错误信息返回给用户\n\n   ```\n   ctx.throw(500)\n   ```\n\n## koa的中间件\n\n```\nctx.method == ctx.request.method == ctx.req.method\nctx.host == ctx.req.url\nctx.url == ctx.request.url == ctx.req.url\nctx.body == ctx.response.body\n```\n\n通过`app.use()`函数来加载中间件；中间件函数是一个带有ctx和next两个参数的函数\n\nctx是执行上下文，封装了request和response等对象\n\nnext是把中间件的执行权交给下游中间件\n\n使用`koa-compose`可以将多个中间件组合成一个单一的中间件，便于重用或导出\n\n```\nconst compose = require('koa-compose')\n\nconst middleware1 = async (ctx, next) => {\n    console.log(1)\n    await next()\n    console.log('1 end')\n}\nconst middleware2 = async (ctx, next) => {\n    console.log(2)\n    await next()\n    console.log('2 end')\n}\nconst middleware3 = async (ctx, next) => {\n    console.log(3)\n    await next()\n    console.log('3 end')\n}\nconst all = compose([middleware1, middleware2, middleware3])\napp.use(all)\n```\n\n[常用koa中间件](https://github.com/koajs/koa/wiki)\n\n1. koa-bodyparser 把post请求的参数解析到`ctx.request.body`中\n\n   ```\n   const bodyParser = require('koa-bodyparser')\n   app.use(bodyParser())\n   ```\n\n2. koa-router  路由处理\n\n   ```\n   const Router = require('koa-router')\n   const router = new Router()\n   router.get('/', async (ctx, next) => {})\n   app.use(router.routes())         // 加载koa-router中间件\n     .use(router.allowedMethods()) // 对异常状态码的处理\n   ```\n\n3. koa-static 静态文件处理\n\n   ```\n   const static = require('koa-static')\n   app.use(static(path.join(__dirname, '/static')))  // 加载静态资源\n   ```\n\n4. Koa-views 模板文件中间件\n\n   ```\n   const views = require('koa-views')\n   app.use(views(__dirname + '/views', { map: { html: 'ejs' } }))  // 加载模板引擎\n   router.get('/', async ctx => {\n    await ctx.render('index')    // 渲染index模板\n   })\n   ```\n\n## 路由\n\n路由是根据URL的变更重新渲染页面布局和内容的过程\n\n前端路由主要解决了两个问题：在页面不刷新的前提下实现URL的变化；及捕捉URL的变化并执行相应的页面逻辑\n\n\n","tags":["koa"]},{"title":"nginx.md","url":"/web/2019/06/20/nginx-md/","content":"# [nginx](nginx.org)\nNginx是一款轻量级的HTTP服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的IO性能，时常用于服务端的反向代理和负载均衡\n\n**Nginx版本**\n\n- Mainline version  开发版\n- Stable version   稳定版\n- legacy version  历史版本\n\n## 基于yum方式安装Nginx\n\n**用yum进行安装必要程序**\n\n```\nyum -y install gcc gcc-c++ autoconf pcre-devel make automake\nyum -y install wget httpd-tools vim\n```\n\n**检查yum源是否存在nginx**\n\n```\nyum list | grep nginx\n```\n\n**去nginx查找最新源**\n\n[http://nginx.org/en/download.html](http://nginx.org/en/download.html) 下面找到stable and mainline versions\n\n```\n[nginx]\nname=nginx repo\nbaseurl=http://nginx.org/packages/OS/OSRELEASE/$basearch/\ngpgcheck=0\nenabled=1\n```\n\n**编辑源**\n\n```\nvim /etc/yum.repos.d/nginx.repo\n```\n\n根据操作系统及版本号修改源的baseurl\n\n```\nbaseurl=http://nginx.org/packages/centos/7/$basearch/\n```\n\n**安装nginx**\n\n```\nyum install nginx\n```\n\n**查看nginx安装目录**\n\n```\nrpm -ql nginx\n```\n\n`rpm` 是 linux的rpm包管理工具\n\n`-q `代表询问模式\n\n`-l `代表返回列表\n\n**查看nginx配置文件的位置**\n\n```\nnginx -t\n```\n\n## nginx配置文件详解\n\n**nginx.confg配置**\n\n```\nuser nginx;           # 运行用户，默认是nginx, 可以不进行设置\nworker_processes  1;  # nginx进程数 一般设置为和CPU核数一样\nerror_log /var/log/nginx/error.log warn; # 错误日志存放目录\npid    /var/run/nginx.pid;               # 进程pid存放目录\nevents {\n    worker_connections 1024;            # 后台进程的最大并发数\n}\nhttp {\n    include /etc/nginx/mime.types;        # 文件扩展名与类型映射表\n    default_type application/octet-stream;    # 默认文件类型\n    log_format main 'xxxx'                    # 设置日志模式\n    access_log /var/log/nginx/access.log main # nginx访问日志存放位置\n    sendfile    on;       # 开启高效传输模式\n    # tcp_nopush    on;   # 减少网络报文的数量\n    keepalive_timeout 65; # 保持连接的时间，也叫超时时间\n    # gzip     on;        # 开启gzip 压缩\n    include /etc/nginx/conf.d/*.conf;   # 包含的子配置项位置和文件\n}\n```\n\n**default.conf**\n\n```02 5\nserver {\n    listen     80;             #配置监听端口\n    server_name  localhost;    # 配置域名\n    location / {\n        root /usr/share/nginx/html;      # 服务器默认启动目录\n        index index.html index.htm;      # 默认访问文件\n    }\n    # error_page 404  /404.html;       # 配置404页面\n    error_page 500 502 503 504 /5x.html;  # 错误状态码的显示页面，配置后需要重启\n    location /50x.html {\n        root /usr/share/nginx/html;\n    }\n}\n```\n\n## nginx服务启动、停止、重启\n\n**启动nginx服务**\n\n```\nnginx     # 直接启动\nsystemctl start nginx.service  # 使用systemctl命令启动\n```\n\n**查询服务的运行状况**\n\n```\nps aux | grep nginx\n```\n\n**停止nginx服务**\n\n```\nnginx -s stop   # 立即停止服务，无论进程是否在工作，直接停止\nnginx -s quit   # 从容停止服务，在进程完成当前工作后在停止\nkillall nginx   # 杀死进程\nsystemctl stop nginx.service  # 使用systemctl停止\n```\n\n**重启nginx服务**\n\n```\nsystemctl restart nginx.service\n```\n\n**重新载入配置文件**\n\n```\nnginx -s reload # 在修改nginx配置文件后，需要重新载入\n```\n\n**查看端口号**\n\n在默认情况下，nginx启动后会监听80端口，从而提供http访问，如果80端口被占用，可以使用`netstat -tlnp`命令查看端口号的占用情况\n\n## 自定义错误页和访问设置\n\n**多错误指向同一个页面**\n\n```\nerror_page 500 502 503 504 /50x.html;    # 将这四个错误代码的时候都跳转到根目录下50x.html\n```\n\nerror_page指令用于自定义错误页面\n\n```\nerror_page 404 /404_error.html;     # 单独为错误指定处理方式\nerror_page 404 http://www.ssmy.cn;  # 为错误指定外部地址\n```\n\n## 访问权限控制\n\n有时候我们的服务器只允许特定主机访问，比如内部OA系统或应用的管理后台系统或某些应用接口，这时需要控制一些IP访问，可以直接在location里进行配置\n\n```\nlocation / {                   # / 表示所有请求都走里面的规则\n    deny 123.123.123.123;        # 禁止指定IP访问\n    allow 345.345.345.345/500;   # 允许指定的IP段访问 345.345.345.345-345.345.345.500\n    allow all;                   # 允许所有ip访问\n    deny  all;                   # 禁止所有ip访问\n}\n```\n\n在同一个块作用域中，先定义的权限指令会覆盖后面的权限指令，后面的权限指令无效\n\n**复杂权限控制匹配**\n\n`=`表示精确匹配\n\n```\nlocation =/img {  # /img 目录允许所有用户访问\n    allow all;      \n}\nlocation =/admin { # /admin 目录进制所有用户访问\n    deny all;\n}\n```\n\n**使用正则表达式设置访问权限**\n\n`~\\`表示使用正则表达式\n\n```\nlocation ~\\.php$ { # 以.php结尾的页面都进制访问\n    deny all;\n}\n```\n\n## nginx设置虚拟主机\n\n虚拟主机是指在一台物理主机服务器上划分出多个磁盘空间，每个磁盘空间都是一个虚拟主机，每台虚拟主机都可以对外提供Web服务，并且互不干扰。在外界看来，虚拟主机就是一台独立的服务器主机，这意味着用户能够利用虚拟主机把多个不同域名的网站部署在同一台服务器上\n\n配置虚拟主机可以基于端口号、IP和域名来设置\n\n可以在`nginx.conf`或`default.conf`中配置，也可以在子文件里新建`.conf`文件进行配置\n\n- 基于端口配置\n\n```\nserver {\n    listen 8001;               # 监听8001端口\n    server_name localhost;     # server name\n    root /home/html;           # 文件存放目录\n    index index.html;          # 首页文件\n}\n```\n\n- 基于IP/域名配置\n\n```\nserver {\n    listen 80;                       # 监听80端口\n    server_name 123.123.123.123或域名;     # server name\n    root /home/html;                 # 文件存放目录\n    index index.html;                # 首页文件\n}\n```\n\n## nginx反向代理设置\n\n**正向代理**\n\n正向代理代理的是客户端。正向代理是客户端想访问目标服务器，但没有权限，代理服务器有访问服务器的权限，同时客户端有访问代理的权限，这时可以通过客户端访问代理服务器，代理服务器访问真实服务器，把内容返回回来\n\n**反向代理**\n\n反向代理代理的是服务器。反向代理是客户端想访问服务器，发送的内容会被发送到代理服务器，代理服务器把请求发送到自己设置好的内部服务器。\n\n**反向代理的用途和好处**\n\n- 安全性\n\n  正向代理的客户端能够在隐藏自身信息的同时访问任意网站，这给网络安全代理了极大的威胁。因此必须把服务器保护起来，使用反向代理客户端，用户只能通过外网来访问代理服务器，并且用户并不知道自己访问的真实服务器是哪一台，可以很好的提供安全保护\n\n- 功能性\n\n  反向代理的主要用途是为多个服务器提供负载均衡，缓存等功能。负载均衡是一个网站的内容被部署在若干服务器上，可以把这些机器看成一个集群，nginx可以将接收到的客户端请求均匀地分配到这个集群中所有的服务器上，从而实现服务器压力的平均分配\n\n```\nserver {\n    listen 80;\n    server_name 请求域名;\n    location / {\n        proxy_pass 被代理的域名或端口;\n    }\n}\n```\n\n**其它反向代理命令**\n\n- `proxy_set_header` 将客户端请求发送给后端服务器之前，更改来自客户端的请求头信息\n- `proxy_connect_timeout` 配置nginx与后端代理服务器尝试建立连接的超时时间\n- `proxy_read_timeout` 配置nginx向后端服务器组发出read请求后，等待相应的超时时间\n- `proxy_send_timeout` 配置nginx向后端服务器组发出write请求后，等待响应的超时时间\n- `proxy_redirect` 用于修改后端服务器返回的响应头中的Location和Refresh\n\n## nginx适配PC或移动设备\n\nNginx通过内置变量`$http_user_agent`可以获取到请求客户端的userAgent, 可以判断用户目前处于移动端还是PC端，从而展示不同的页面给用户\n\n```\nserver {\n    listen 80;\n    server_name nginx2.jspang.com;\n    location / {\n        root /usr/share/nginx/pc; # 默认访问pc端页面\n        if ($http_user_agent ~* '(Android|webOS|iPhone|iPod|BlackBerry)') {\n            root /usr/share/nginx/mobile; # 访问移动端页面\n        }\n        index index.html;\n    }\n}\n```\n\n\n\n## nginx设置Gzip压缩\n\nGzip是网页的一种网页压缩技术，经过gzip压缩后，页面大小可以变为原来的30%甚至更小。更小的网页会让用户浏览的体验更好，速度更快。gzip网页压缩的实现需要浏览器和服务器的支持。\n\n当浏览器支持Gzip压缩时，会在请求消息中包含`Accept-Encoding:gzip`这样nginx就会向浏览器发送Gzip后的内容,同时在相应信息头中加入`Content-Encoding: gzip`,声明这是gizp后的内容，告知浏览器要先解压后才能解析输出\n\n```\nhttp {\n    gzip on;\n    gzip_types text/plain application/javascript text/css;\n}\n```\n\n**Gzip配置项**\n\n- `gzip` 用于开启或关闭gzip模块\n- `gzip_buffers` 设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流\n- `gzip_comp_level` Gzip压缩比，压缩级别是1-9，1的压缩级别最低，9的压缩级别最高。压缩级别越高压缩率越大，压缩时间越长\n- `gzip_disable` 可以通过该指令对一些特定的user-agent不使用压缩功能\n- `gzip_min_length` 设置允许压缩的页面最小字节数，页面字节数从响应的消息头content-length中获取\n- `gzip_http_version` 识别http协议版本，其值可以是1.0或1.1\n- `gzip_proxied` 用于设置启用或禁用从代理服务器上收到相应内容gzip压缩\n- `gzip_vary`用于在响应消息头中添加Vary: Accept-Encoding, 使代理服务器根据请求头中的Accept-Encoding识别是否启用gzip压缩\n\n\n"}]